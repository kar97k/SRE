#на вход подаётся access.log nginx, записи вида:
217.24.70.209 [-] - 00:1a:d0:1c:a7:62 [13/Mar/2019:00:02:12 +0200] MGMT GET /api/v1/epg/list?lang=lv&channelId=21884993&startDate=1552420800&stopDate=1552521600&from=0&to=1000 HTTP/1.1 "200" 33 "-" "SmartLabs/5.17009.1710 (albis9090; Albis-9090) SmartSDK/release-4.19.1-rc7.1 (https) Qt/4.8.4 API/0.42.4" "10.25.190.13:8084" 443 "fe-iptv.baltcom.lv:443" 0.003 0.002 "0"

#MAC     количество запросов с кодом 200 : количество всех остальных 
cat | access.log perl -an -E '  '
if ($F[10] =~ "200") {$h{$F[3]}[0]++} else {$h{$F[3]}[1]++} }{ for (keys %h) {print "$_\t$h{$_}[0] : $h{$_}[1]\n"}

if ($F[10] =~ "200") {$h{$F[3]}[0]++} else {$h{$F[3]}[1]++} }{ for (keys %h) {printf "$_\t%-4d: %d\n", $h{$_}[0], $h{$_}[1]}

#уникальные ошибки
cat access.log | perl -lna -E 'print $F[10] unless $h{$F[10]}++'

#код ошибки и количество запросов с этим кодом
perl -lna -E ''
$h{$F[10]}++ }{ for (keys %h) {print "$_ : $h{$_}"}
#в осортированном виде
perl -lna -E ''
$h{$F[10]}++ }{ print "$_ : $h{$_}" for sort { $h{$b} <=> $h{$a} } keys %h;

#Выводит тип запроса, общее количество, количество ошибок, отношение ошибок к успешным запросам
perl -lna -E ''
$F[8] =~ m!(/.*\?)!; $h{$1}[0]++; $h{$1}[1]++ if $F[10] eq q/"502"/ }{ for (keys %h) {$r = $h{$_}[1]/$h{$_}[0] if $h{$_}[1]; printf "%-40s %-10d %-5d % 0.3f\n", $_, $h{$_}[0],  $h{$_}[1], $r if $h{$_}[1] }
#отсортировано по первому столбцу, запросы у которых отсутствует ошибка 502 не выводятся
perl -lna -E ''
$F[8] =~ m!(/.*\?)!; $h{$1}[0]++; $h{$1}[1]++ if $F[10] eq q/"502"/ }{ for (sort { $h{$b}[0] <=> $h{$a}[0] } keys %h) {$r = $h{$_}[1]/$h{$_}[0] if $h{$_}[1]; printf "%-40s %-10d %-5d % 0.3f\n", $_, $h{$_}[0],  $h{$_}[1], $r if $h{$_}[1] }

#Сматчить время часы:минуты:секунды 
$F[4] =~ m!:(\d{2}:\d{2}:\d{2})!;
#количество запросов определённого типа в минуту
if ( $F[8] =~ m!/api/v1/notifications/subscribe?! ) { $F[4] =~ m!:(\d{2}:\d{2}):\d{2}!; $h{$1}++ } }{ printf "%-40s %-10d\n", $_, $h{$_} for sort keys %h

#тип запроса заканчивается на ism ( например  /dash/CH_SUPERTENNIS_HD.ism  на  nej-hub-mstor01 )
if ( $F[8] =~ m!(/.*\.ism)! ) { $h{$1}[0]++; $h{$1}[1]++ if $F[10] eq q/"404"/ } }{ printf "%-40s %-10d %-7d % 0.3f\n", $_, $h{$_}[0],  $h{$_}[1], $h{$_}[1]/$h{$_}[0] for sort { $h{$b}[0] <=> $h{$a}[0] }  keys %h 

#сомнительная задача 
#плохой алгоритм, приходится отдельно выводит послдений блок строк
#на вход подаётся вывод ls -la, он отсортирован по дате. Требуется отсортировать по размеру строки в группе имеющей одну дату
cat ls_la_sorted_by_day_example | perl -lan -E ''
if ($F[6] == $prev) { $h{$_} = $F[4] }; next if $F[6] == $prev; for (sort { $h{$a} <=> $h{$b} } keys %h) { print "$_ : $h{$_}" }; $prev = $F[6]; undef %h; $h{$_} = $F[4]; print "-" x 91  }{ for (sort { $h{$b} <=> $h{$a} } keys %h) { print }
#короче
if ($F[6] == $prev) { $h{$_} = $F[4] }; next if $F[6] == $prev; print "$_ : $h{$_}" for sort { $h{$b} <=> $h{$a} } keys %h; $prev = $F[6]; undef %h; $h{$_} = $F[4]; print "-" x 91  }{ print for sort { $h{$b} <=> $h{$a} } keys %h

#Проверить делает ли приставка повторный запрос к конкретному методу из API (например /api/v1/userfeed/items), если пердыдущий запрос завершился 502 ошибкой
cat find_5xx_userfeed | perl -lna -E ''
$F[8] =~ m!(/.*\?)!; say $_ if $h{"$F[3]---$1"}; $h{"$F[3]---$1"} = $_ if $F[10] eq q/"502"/;
#выводит MAC + метод апи, если запросов к этому методу апи было меньше 2-x
cat userfeed_22-00_23-59_sdp01_sdp02 | perl -na -E ''
$F[8] =~ m!(/.*)\?!; push @{ $h{"$F[3] + $1"} }, $_; }{ for (keys %h) { print @{$h{$_}} if scalar @{$h{$_}} < 2 }
#выводит MAC + метод апи, если запросов к этому методу апи было больше одного, с заголовками
$F[8] =~ m!(/.*)\?!; push @{ $h{"$F[3] + $1"} }, $_; }{ for (keys %h) { say "$_\n\n", @{$h{$_}} if scalar @{$h{$_}} > 1 }



#создаёт таблицу ключ - значение в перловом синтаксисе с парами "1 строка : 60-я", "2-я : 61 - я" и т.д.
perl -lna -E 'push @arr, qq{"$_"} if 1..58; $arr[$i++] .= qq{ => "$_",} if 60..117 }{ print join "\n", @arr'
